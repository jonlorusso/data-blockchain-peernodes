package com.swatt.chainNode.ingestor;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.swatt.chainNode.ChainNode;
import com.swatt.chainNode.ChainNodeListener;
import com.swatt.chainNode.ChainNodeTransaction;
import com.swatt.chainNode.dao.BlockData;
import com.swatt.chainNode.dao.CheckProgress;
import com.swatt.util.general.OperationFailedException;
import com.swatt.util.sql.ConnectionPool;

public class ChainNodeIngestor implements ChainNodeListener {
    private static final Logger LOGGER = LoggerFactory.getLogger(ChainNodeIngestor.class);

    private static final String BLOCKDATA_QUERY = String.format("SELECT %s FROM %s WHERE BLOCKCHAIN_CODE = ? AND HEIGHT = ?", BlockData.getSqlColumnList(), BlockData.getStandardTableName());
    private static final String BLOCKDATA_INSERT = "INSERT INTO BLOCK_DATA (BLOCKCHAIN_CODE, HASH, TRANSACTION_COUNT, HEIGHT, DIFFICULTY, DIFFICULTY_SCALE, REWARD, REWARD_SCALE, MERKLE_ROOT, TIMESTAMP, BITS, SIZE, VERSION_HEX, NONCE, PREV_HASH, NEXT_HASH, AVG_FEE, AVG_FEE_SCALE, AVG_FEE_RATE, AVG_FEE_RATE_SCALE, INDEXED, LARGEST_TX_HASH, LARGEST_TX_AMOUNT, LARGEST_TX_AMOUNT_SCALE, LARGEST_FEE, LARGEST_FEE_SCALE, SMALLEST_FEE, SMALLEST_FEE_SCALE, INDEXING_DURATION) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    private static final String BLOCKDATA_MAX_ID_QUERY = "Select MAX(ID) FROM BLOCK_DATA";

    private boolean overwriteExisting = false;

    private Thread historicalIngestionThread;
    
    private ConnectionPool connectionPool;
    private ChainNode chainNode;

    public ChainNodeIngestor(ConnectionPool connectionPool, ChainNode chainNode) {
        super();

        this.connectionPool = connectionPool;
        this.chainNode = chainNode;
        
        chainNode.addChainNodeListener(this);
    }
    
    public ChainNode getChainNode() {
        return chainNode;
    }

    @Override
    public void newBlockAvailable(ChainNode chainNode, BlockData blockData) {
        try (Connection connection = connectionPool.getConnection()) {
            LOGGER.info(String.format("Block available, storing: %d", blockData.getHeight()));
            BlockData.insertBlockData(connection, blockData);
        } catch (SQLException e) {
            LOGGER.error("Exception caught while storing new block: " + e.getMessage());
        }
    }

    @Override
    public void newTransactionsAvailable(ChainNode chainNode, ChainNodeTransaction[] chainTransactions) {
        throw new UnsupportedOperationException("Unimplemented.");
    }

    private int getMaxBlockDataId(Connection connection) throws SQLException {
        int autoGeneratedKey = 0;

        PreparedStatement preparedStatement = connection.prepareStatement("Select MAX(ID) FROM BLOCK_DATA");
        ResultSet resultSet = preparedStatement.executeQuery();

        if (resultSet.next())
            autoGeneratedKey = resultSet.getInt(1);

        return autoGeneratedKey;
    }

    // TODO this should be moved to BlockData
    private BlockData insertBlockData(Connection connection, PreparedStatement insertPreparedStatement, PreparedStatement maxIdPreparedStatement, BlockData blockData) throws SQLException {
        boolean storedAutoCommitValue = connection.getAutoCommit();
        connection.setAutoCommit(false);

        insertPreparedStatement.clearParameters();
        insertPreparedStatement.setString(1, blockData.getBlockchainCode());
        insertPreparedStatement.setString(2, blockData.getHash());
        insertPreparedStatement.setInt(3, blockData.getTransactionCount());
        insertPreparedStatement.setLong(4, blockData.getHeight());
        insertPreparedStatement.setLong(5, (long) (blockData.getDifficulty() * Math.pow(10, blockData.getDifficultyScale())));
        insertPreparedStatement.setInt(6, blockData.getDifficultyScale());
        insertPreparedStatement.setLong(7, (long) (blockData.getReward() * Math.pow(10, blockData.getRewardScale())));
        insertPreparedStatement.setInt(8, blockData.getRewardScale());
        insertPreparedStatement.setString(9, blockData.getMerkleRoot());
        insertPreparedStatement.setLong(10, blockData.getTimestamp());
        insertPreparedStatement.setString(11, blockData.getBits());
        insertPreparedStatement.setInt(12, blockData.getSize());
        insertPreparedStatement.setString(13, blockData.getVersionHex());
        insertPreparedStatement.setLong(14, blockData.getNonce());
        insertPreparedStatement.setString(15, blockData.getPrevHash());
        insertPreparedStatement.setString(16, blockData.getNextHash());
        insertPreparedStatement.setLong(17, (long) (blockData.getAvgFee() * Math.pow(10, blockData.getAvgFeeScale())));
        insertPreparedStatement.setInt(18, blockData.getAvgFeeScale());
        insertPreparedStatement.setLong(19, (long) (blockData.getAvgFeeRate() * Math.pow(10, blockData.getAvgFeeRateScale())));
        insertPreparedStatement.setInt(20, blockData.getAvgFeeRateScale());
        insertPreparedStatement.setLong(21, blockData.getIndexed());
        insertPreparedStatement.setString(22, blockData.getLargestTxHash());
        insertPreparedStatement.setLong(23, (long) (blockData.getLargestTxAmount() * Math.pow(10, blockData.getLargestTxAmountScale())));
        insertPreparedStatement.setInt(24, blockData.getLargestTxAmountScale());
        insertPreparedStatement.setDouble(25, blockData.getLargestFee());
        insertPreparedStatement.setInt(26, blockData.getLargestFeeScale());
        insertPreparedStatement.setLong(27, (long) (blockData.getSmallestFee() * Math.pow(10, blockData.getSmallestFeeScale())));
        insertPreparedStatement.setInt(28, blockData.getSmallestFeeScale());
        insertPreparedStatement.setLong(29, blockData.getIndexingDuration());
        insertPreparedStatement.executeUpdate();

        blockData.setId(getMaxBlockDataId(connection));

        if (storedAutoCommitValue) {
            connection.commit();
            connection.setAutoCommit(true);
        }

        return blockData;
    }

    private BlockData getBlockData(PreparedStatement preparedStatement, long height) throws SQLException {
        preparedStatement.clearParameters();
        preparedStatement.setString(1, chainNode.getBlockchainCode());
        preparedStatement.setLong(2, height);

        List<BlockData> blockDatas = BlockData.getBlockDatas(preparedStatement);
        if (!blockDatas.isEmpty())
            return blockDatas.get(0);

        return null;
    }

    public void startHistoricalIngestion() {
        if (historicalIngestionThread != null)
            return;
        
        historicalIngestionThread = new Thread(() -> {
            try (Connection connection = connectionPool.getConnection()) {
                PreparedStatement queryPreparedStatement = connection.prepareStatement(BLOCKDATA_QUERY);
                PreparedStatement insertPreparedStatement = connection.prepareStatement(BLOCKDATA_INSERT);
                PreparedStatement maxIdPreparedStatement = connection.prepareStatement(BLOCKDATA_MAX_ID_QUERY);

                long height = chainNode.fetchBlockCount();

                CheckProgress checkProgress = CheckProgress.call(connection, chainNode.getCode());
                long stopHeight = checkProgress.getBlockCount();
                
                while (height > stopHeight) {
                    BlockData blockData = getBlockData(queryPreparedStatement, height);
                    if (blockData != null && !overwriteExisting) {
                        height = height - 1;
                        continue;
                    }

                    blockData = chainNode.fetchBlockData(height);
                    insertBlockData(connection, insertPreparedStatement, maxIdPreparedStatement, blockData);

                    LOGGER.info(String.format("Block ingested: %d", height));

                    height = height - 1;
                }
            } catch (OperationFailedException | SQLException e) {
                historicalIngestionThread = null;
            }
        }, "HistoricalIngestion-" + chainNode.getCode());

        historicalIngestionThread.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread thread, Throwable throwable) {
                historicalIngestionThread = null;
            }
        });
        
        historicalIngestionThread.start();
    }

    public void startNewBlockIngestion() {
        chainNode.fetchNewBlocks();
    }
}
